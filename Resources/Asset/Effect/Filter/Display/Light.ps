/******************************************************************************
**	Includes
******************************************************************************/
#include "../Filter.vs"
#include "../../GBuffer.sl"
#include "../../GlobalIllumination/Struct.sl"
#include "../../GlobalIllumination/Helper.sl"
#include "../../Shadow/PoissonDisc.sl"

/******************************************************************************
**	Defines
******************************************************************************/
 #define LIGHT_POWER_RATIO 1.0f / 64000.0f // Keep sun to 1.0f value

/******************************************************************************
**	Resources
******************************************************************************/
Texture2D tAlbedo										: register(t0);
Texture2D tNormal										: register(t1);
Texture2D tDepth										: register(t2);
Texture3D tVoxelColor									: register(t3);
StructuredBuffer<DirectionalLight> aDirectionalLight 	: register(t4);
Texture2D tDirectionalShadowMap							: register(t5);
StructuredBuffer<PointLight> aPointLight 				: register(t6);
TextureCubeArray tPointShadowMap						: register(t7);
TextureCube tEnvironment								: register(t8);
Texture2D tNoise										: register(t9); 

/******************************************************************************
**	Structs
******************************************************************************/
struct Fragment
{	
	float3 	Albedo;
	float3 	Normal;
	float3  Position; 
	float3	View;
	float3	Fresnel;
	
	float 	NdotV;
	float 	Depth;
	float  	Metallic;
	float  	Roughness;
};

struct LightParameter
{
	float 	NdotL; 
	float 	NdotH;
	float 	VdotH;
};

/******************************************************************************
**	Helpers
******************************************************************************/
static float aWeight[6] = 
{
	K_PI / 4.0f, 
	3.0f * K_PI / 20.0f,
	3.0f * K_PI / 20.0f,
	3.0f * K_PI / 20.0f,
	3.0f * K_PI / 20.0f,
	3.0f * K_PI / 20.0f,
};

static float3 aConeDirection[6] =
{
	float3(+0.0f, 		+1.0f, 	+0.0f),
	float3(+0.0f, 		+0.5f, 	+0.866025f),
	float3(+0.823639f, 	+0.5f, 	+0.267617f),
	float3(+0.509037f, 	+0.5f, 	-0.700629f),
	float3(-0.509037f, 	+0.5f,	-0.700629f),
	float3(-0.823639f, 	+0.5f, 	-0.267617f),
};

/******************************************************************************
**	Pixel Shader Output
******************************************************************************/
struct PS_OUTPUT
{
	float3 DirectLighting		: SV_Target0;
	float4 IndirectLighting		: SV_Target1;
	float4 AmbientOcclusion		: SV_Target2;
};


/******************************************************************************
**	Area
******************************************************************************/
float ComputeSphereArea(in float _fRadius)
{
	return 4.0f * K_PI * _fRadius * _fRadius;
}

/******************************************************************************
**	ConvertLumenToLux
**	Compute lumen/mÂ² (lux)
******************************************************************************/
float ConvertLumenToLux(in float _fLumen, in float _fArea)
{
	return _fLumen / _fArea;
}

/******************************************************************************
**	ComputeFresnel
******************************************************************************/
#define FRESNEL_SCHLICK
float3 ComputeFresnel(in float3 _vF0, in float _fRoughness, in float _fNdotV)
{
#ifdef FRESNEL_SCHLICK
	return _vF0 + (max((float3)1.0f - _fRoughness, _vF0) - _vF0) * pow(1.0f - _fNdotV, 5.0f);

#else	// Default
	return _vF0;
#endif
}

/******************************************************************************
**	ComputeGeometricAttenuation
**	http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html
******************************************************************************/
//#define GEOMETRIC_ATTENUATION_NEUMANN
//#define GEOMETRIC_ATTENUATION_COOK-TORRANCE
//#define GEOMETRIC_ATTENUATION_KELEMEN
#define GEOMETRIC_ATTENUATION_GGX_SCHLICK
//#define GEOMETRIC_ATTENUATION_SMITH_HEIGHT_CORRELATED
float ComputeGeometricAttenuation(in Fragment _kFragment, in LightParameter _kLightParameter)
{
#if defined(GEOMETRIC_ATTENUATION_NEUMANN)
	float fNumerator = _kLightParameter.NdotL * _kFragment.NdotV;
	float fDenumerator = max(_kLightParameter.NdotL, _kFragment.NdotV);
	return fNumerator / fDenumerator;
	
#elif defined(GEOMETRIC_ATTENUATION_COOK)
	float fFactor1 = (2.0f * _kLightParameter.NdotH * _kFragment.NdotV) / _kLightParameter.VdotH;
	float fFactor2 = (2.0f * _kLightParameter.NdotH * _kLightParameter.NdotL) / _kLightParameter.VdotH;
	return min(1.0f, min(fFactor1, fFactor2));
	
#elif defined(GEOMETRIC_ATTENUATION_KELEMEN)
	float fNumerator = _kLightParameter.NdotL * _kFragment.NdotV;
	float fDenumerator = _kLightParameter.VdotH * _kLightParameter.VdotH;
	return fNumerator / fDenumerator;
	
#elif defined(GEOMETRIC_ATTENUATION_GGX_SCHLICK)
	float fK = pow(_kFragment.Roughness + 1.0f, 2.0f) / 8.0f;
    float fFactor1 = _kFragment.NdotV / (_kFragment.NdotV * (1.0f - fK) + fK);
	float fFactor2 = _kLightParameter.NdotL / (_kLightParameter.NdotL * (1.0f - fK) + fK);
	return fFactor1 * fFactor2;
	
#elif defined(GEOMETRIC_ATTENUATION_SMITH_HEIGHT_CORRELATED)
	// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf
	// Caution : the " _fNdotL *" and " _fNdotV *" are explicitely inversed , this is not a mistake .
	float fRoughnessSquared = _kFragment.Roughness * _kFragment.Roughness;
	float fLambdaV = _kLightParameter.NdotL * sqrt((-_kFragment.NdotV * fRoughnessSquared + _kFragment.NdotV) * _kFragment.NdotV + fRoughnessSquared);
	float fLambdaL = _kFragment.NdotV * sqrt((-_kLightParameter.NdotL * fRoughnessSquared + _kLightParameter.NdotL) * _kLightParameter.NdotL + fRoughnessSquared); 
	return 0.5f / (fLambdaV + fLambdaL);
	
#else	// Default
	return _kLightParameter.NdotL * _kFragment.NdotV;
#endif	
}

/******************************************************************************
**	ComputeNormalDistribution
**	http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html
******************************************************************************/
// #define NORMAL_DISTRIBUTION_BECKMAN
#define NORMAL_DISTRIBUTION_GGX
// #define NORMAL_DISTRIBUTION_GGX_TROWBRIDGE_REITZ
float ComputeNormalDistribution(in Fragment _kFragment, in LightParameter _kLightParameter)
{	
	float fRoughnessFactor = pow(_kFragment.Roughness, 4);
	
#if defined(NORMAL_DISTRIBUTION_BECKMAN)
	float fNdotH_2 = _kLightParameter.NdotH * _kLightParameter.NdotH;
	float fNdotH_4 = fNdotH_2 * fNdotH_2;
	float fFactor1 = 1.0f / (K_PI * fRoughnessFactor * fNdotH_4);
	float fFactor2 = (fNdotH_2 - 1.0f) / (fRoughnessFactor * fNdotH_2);
    return fFactor1 * exp(fFactor2);
	
#elif defined(NORMAL_DISTRIBUTION_GGX)
	float NdotH  = max(_kLightParameter.NdotH, 0.0f);
    float NdotH2 = NdotH*NdotH;
    float fNomimator   = fRoughnessFactor;
    float fDenominator = (NdotH2 * (fRoughnessFactor - 1.0f) + 1.0f);
    fDenominator = fDenominator * fDenominator;
    return fNomimator / fDenominator;
	
#elif defined(NORMAL_DISTRIBUTION_GGX_TROWBRIDGE_REITZ)
	float fFactor = (_kLightParameter.NdotH * _kLightParameter.NdotH) * (fRoughnessFactor - 1.0f) + 1.0f;
	return fRoughnessFactor / K_PI * (fFactor * fFactor);
	
#else // BLING-PHONG
	float fFactor1 = 1.0f / (fRoughnessFactor);
	float fFactor2 = pow(_kLightParameter.NdotH, (2.0f / fRoughnessFactor) - 2.0f);
	return fFactor1 * fFactor2;
#endif	
}

/******************************************************************************
**	Specular BRDF
**	fs = F(v,h,f0)G(v,l,h)D(h,a)
**			4(n.v)(n.l)
******************************************************************************/
float3 BRDF_Specular(in Fragment _kFragment, in LightParameter _kLightParameter)
{		
	float3 F = _kFragment.Fresnel;
	float G = ComputeGeometricAttenuation(_kFragment, _kLightParameter);
	float D = ComputeNormalDistribution(_kFragment, _kLightParameter);		

	return (F * G * D) / (4.0f * _kLightParameter.NdotL * _kFragment.NdotV); 
}

float test(in float _fF90, in float costheta)
{
	return 1.0f + (_fF90 - 1.0f) * pow(1.0f - costheta, 5);
	
}

/******************************************************************************
**	Diffuse BRDF
******************************************************************************/
#define DIFFUSE_DISNEY
float3 BRDF_Diffuse(in Fragment _kFragment, in LightParameter _kLightParameter)
{
#if defined(DIFFUSE_DISNEY) 
	float3 vDiffuse = _kFragment.Albedo;
	float fF90 = 0.5f + 2.0 * _kLightParameter.VdotH * _kLightParameter.VdotH * _kFragment.Roughness;
	float lightScatter = test(fF90, _kLightParameter.NdotL);
	float viewScatter = test(fF90, _kFragment.NdotV);
	return vDiffuse * lightScatter * viewScatter;
	
#else	// LAMBERT
	return _kFragment.Albedo;
#endif
}

float TraceCone(in float3 _vOrigin, in float3 _vDirection, in float _fAperture)
{
	float fAmbientOcclusion = 0.0f;
	
	float fDistance = 3.0f * VOXEL_HALF_SIZE;
	float fDistanceLimit = 3.5f * VOXEL_HALF_SIZE;
	float fStartDistance = fDistance;
	while (fDistance < fDistanceLimit && fAmbientOcclusion < 1.0f)
	{
		uint uiMipLevel = (fDistance / fStartDistance) - 1;
		float fDiameter = 2.0f * fDistance * _fAperture;
		float3 vPosition = _vOrigin + _vDirection * fDiameter;
		float3 vTexcoord = PackVoxelTexcoord2(vPosition, ((uint)GRID_SIZE) >> uiMipLevel);
		fAmbientOcclusion += tVoxelColor.SampleLevel(sPointSampler, vTexcoord, uiMipLevel).a * fDiameter;
		
		fDistance += fDiameter * 0.5f;
	}
	
	return fAmbientOcclusion;
}

float3 PackVoxelTexcoord3(in float3 _vPosition, in float _fSize)
{
	float3 vTexcoord = (_vPosition + 1.0f) * 0.5f;
	vTexcoord *= (_fSize-1) / _fSize;
	
	return vTexcoord;
}

float3 TraceCone2(in float3 _vOrigin, in float3 _vDirection)
{
	float fAlpha = K_PI / 4.0f;
	float fDistance = 3.0f * VOXEL_HALF_SIZE;
	float fDistanceLimit = 16.0f * VOXEL_HALF_SIZE;
	float3 vValue = (float3)0.0f;
	float fStartDistance = fDistance;
	float fAperture = tan(fAlpha);
	while (fDistance < fDistanceLimit && vValue.r < 1.0f)
	{
		uint uiMipLevel = (fDistance / fStartDistance) - 1;
		float fDiameter = 2.0f * fDistance * fAperture;
		float3 vPosition = _vOrigin + _vDirection * fDiameter;
		//float3 vTexcoord = PackVoxelTexcoord2(_vOrigin, ((uint)GRID_SIZE) >> uiMipLevel);
		float3 vTexcoord = PackVoxelTexcoord3(vPosition, ((uint)GRID_SIZE) >> uiMipLevel);
		vValue += tVoxelColor.SampleLevel(sPointSampler, vTexcoord, uiMipLevel).rgb;
		fDistance += fDiameter * 0.5f;
	}
	
	return vValue;
}

/******************************************************************************
**	Percentage Closer Soft Shadow - Directional
******************************************************************************/
float PCSS_Directional(in float3 _vPosition, in float4x4 _mViewProjection)
{
	static float fBias = 0.05f;
	static float fTexelFactor = 64.0f/1024.0f;
	static float fPenumbraFactor = 4.0f * fTexelFactor;
	
	// Compute Shadow Texcoord
	float4 vPositionCS = mul(float4(_vPosition, 1.0f), _mViewProjection);
	vPositionCS.xy = vPositionCS.xy * 0.5 + 0.5; 
	vPositionCS.y *= -1.0f;
	
	// Compute Penumbra from Blocker depth avg
	float fGeometryDepth = vPositionCS.z - fBias;
	float fBlockerDepth = 0.0f; uint uiBlockerCount = 0;
	for (uint uiSample = 0; uiSample < POISSON_DISK_FAST_SIZE; ++uiSample)
	{
		float2 vOffset = GET_POISSON_DISK_FAST(uiSample) * fTexelFactor; 
		float fDepth = tDirectionalShadowMap.SampleLevel(sPointSampler, vPositionCS.xy + vOffset, 0).r;
		if(fDepth < fGeometryDepth)
		{
			fBlockerDepth += fDepth;
			++uiBlockerCount; 
		}
	}
	if(uiBlockerCount == 0) return 1.0f;
	fBlockerDepth /= uiBlockerCount;
	float fPenumbra = (fGeometryDepth - fBlockerDepth) / fBlockerDepth * fPenumbraFactor;
	
	// Perform filtering
	float fShadow = 0.0f;
	for (uiSample = 0; uiSample < POISSON_DISK_HIGHEST_SIZE; ++uiSample)
	{
		fShadow += tDirectionalShadowMap.SampleCmpLevelZero(sShadowSampler, vPositionCS.xy + GET_POISSON_DISK_HIGHEST(uiSample) * fPenumbra, fGeometryDepth).r;
	}

	return fShadow / POISSON_DISK_HIGHEST_SIZE;
}

/******************************************************************************
**	Percentage Closer Soft Shadow - Point
******************************************************************************/
float PCSS_Point(in float3 _vDirection, in float _fDistance)
{
	static float fBias = 0.05f;
	
	float fTexelFactor = 1.0f/256.0f;
	float fGeometryDepth = _fDistance - fBias;
	float4 vSample = float4(_vDirection.xyz, 0.0f);

	// Compute Penumbra from Blocker depth avg
	float fBlockerDepth = 0.0f; uint uiBlockerCount = 0;
	for (uint uiSample = 0; uiSample < POISSON_DISK_FAST_SIZE; ++uiSample)
	{
		float4 vOffset = float4(GET_POISSON_DISK_FAST(uiSample) * fTexelFactor, 0.0f, 0.0f); 
		float fDepth = tPointShadowMap.SampleLevel(sPointSampler, vSample + vOffset, 0).r;
		if(fDepth < fGeometryDepth)
		{
			fBlockerDepth += fDepth;
			++uiBlockerCount; 
		}
	}
	if(uiBlockerCount == 0) return 1.0f;
	fBlockerDepth /= uiBlockerCount;
	
	float fPenumbra = (fGeometryDepth - fBlockerDepth) / fBlockerDepth;
	 
	float fTexelFactor2 = 64.0f/256.0f * fPenumbra;

	// Perform filtering
	float fShadow = 0.0f;
	for (uiSample = 0; uiSample < POISSON_DISK_HIGHEST_SIZE; ++uiSample)
	{
		float4 vOffset = float4(GET_POISSON_DISK_HIGHEST(uiSample) * fTexelFactor2, 0.0f, 0.0f); 
		fShadow += tPointShadowMap.SampleCmpLevelZero(sShadowSampler, vSample + vOffset, fGeometryDepth).r;
	}

	return fShadow / POISSON_DISK_HIGHEST_SIZE;
}

/******************************************************************************
**	ComputeLightParameter
******************************************************************************/
LightParameter ComputeLightParameter(in Fragment _kFragment, in float3 _vLight)
{
	LightParameter kLightParameter = (LightParameter)0.0f;
	kLightParameter.NdotL = dot(_kFragment.Normal, _vLight);
	
	float3 vHalf = normalize(-_kFragment.View + _vLight);
	kLightParameter.NdotH = dot(_kFragment.Normal, vHalf);
	kLightParameter.VdotH = dot(_kFragment.View, vHalf);
	
	return kLightParameter;
}

/******************************************************************************
**	ComputeLight_Direct (Reflectance)
******************************************************************************/
float3 ComputeLight_Direct(in Fragment _kFragment, in float3 _vLight, in float3 _vRadiance)
{	
	LightParameter kLightParameter = ComputeLightParameter(_kFragment, _vLight);
	if(kLightParameter.NdotL <= 0.0f)
	{
		return 0.0f;
	}	
	
	// Compute BRDF Diffuse and Specular (Cook-Torrence)
	float3 vDiffuse = BRDF_Diffuse(_kFragment, kLightParameter); 
	float3 vSpecular = BRDF_Specular(_kFragment, kLightParameter);  
	float3 vDiffuseFactor = ((float3)1.0f - _kFragment.Fresnel) * (1.0f - _kFragment.Metallic);		
	
	return (vDiffuseFactor * vDiffuse / K_PI + vSpecular) * _vRadiance * kLightParameter.NdotL;
}

/******************************************************************************
**	Direct Directional Light
******************************************************************************/
float3 ComputeLight_Direct_Directional(in Fragment _kFragment)
{	
	float3 vReflectance = (float3)0;
	
	uint uiSize, uiElementByte;
	aDirectionalLight.GetDimensions(uiSize, uiElementByte);
	[loop]
	for(uint uiLight = 0; uiLight < uiSize; ++uiLight)
	{
		DirectionalLight kLight = aDirectionalLight[uiLight]; 
		float3 vRadiance = kLight.Color * kLight.Power * LIGHT_POWER_RATIO;
		vReflectance += ComputeLight_Direct(_kFragment, -kLight.Direction, vRadiance);

		// Add shadow for this light
		float fShadow = PCSS_Directional(_kFragment.Position, kLight.ViewProjection);
		vReflectance *= fShadow;
	}
	
	return vReflectance;
}

/******************************************************************************
**	Direct Point Light
******************************************************************************/
float3 ComputeLight_Direct_Point(in Fragment _kFragment)
{	
	float3 vReflectance = (float3)0;
	
	uint uiSize, uiElementByte;
	aPointLight.GetDimensions(uiSize, uiElementByte);
	
	[loop]
	for(uint uiLight = 0; uiLight < uiSize; ++uiLight)
	{
		PointLight kLight = aPointLight[uiLight]; 

		// Compute illuminance
		float3 vLightToFragment = kLight.Position - _kFragment.Position;
		float3 vLight = normalize(vLightToFragment);
		float fDistance = length(vLightToFragment);
		float fAttenuation = 1.0f / pow(max(fDistance, 0.01), 2.0f);

		// Compute lux for this point light
		float fArea = ComputeSphereArea(kLight.Radius);
		float fPower = ConvertLumenToLux(kLight.Power, fArea);
		
		// Compute reflectance
		float3 vRadiance = kLight.Color * kLight.Power * LIGHT_POWER_RATIO * fAttenuation;
		vReflectance += ComputeLight_Direct(_kFragment, vLight, vRadiance);
		
		float fShadow = PCSS_Point(-vLight, fDistance);
		vReflectance *= fShadow;
	}
	
	return vReflectance;
}

/******************************************************************************
**	Dithering
******************************************************************************/
float3 ComputeDithering(in float2 _vTexcoord)
{
	return (tNoise.Sample(sPointSampler, _vTexcoord).xyz / 255.0f);
}

/******************************************************************************
**	Pixel Shader Default
******************************************************************************/
PS_OUTPUT PixelDefault(VS_OUTPUT _input)
{
	PS_OUTPUT output = (PS_OUTPUT)0;

	// Skip if there is no geometry
	Fragment kFragment = (Fragment)0;
	
	// Compute fragment position, view & depth
	kFragment.Depth = tDepth.Sample(sPointSampler, _input.Texcoord).r;
	kFragment.Position = ComputeWorldPosition(_input.Texcoord, kFragment.Depth);
	kFragment.View = normalize(kFragment.Position - CAMERA_POSITION);
	if(kFragment.Depth >= 1.0f)
	{
		output.DirectLighting = tEnvironment.Sample(sLinearSampler, kFragment.View).xyz;
		return output; 
	}
	
	// Unpack fragment
	float4 vAlbedo = tAlbedo.Sample(sPointSampler, _input.Texcoord);
	float4 vNormal = tNormal.Sample(sPointSampler, _input.Texcoord);
	kFragment.Albedo = vAlbedo.xyz;
	kFragment.Normal = vNormal.xyz;
	kFragment.Metallic = min(0.7f, vAlbedo.w);
	kFragment.Roughness = max(0.07f, vNormal.w);
	
	// Compute fresnel
	float3 vF0 = lerp(MATERIAL_PLASTIC, kFragment.Albedo, kFragment.Metallic);
	kFragment.NdotV = dot(kFragment.Normal, -kFragment.View);
	kFragment.Fresnel = ComputeFresnel(vF0, kFragment.Roughness, kFragment.NdotV); 
	
	// Compute Direct Light (Reflectance)
	float3 vReflectance = (float3)0.0f;
	vReflectance += ComputeLight_Direct_Directional(kFragment);
	vReflectance += ComputeLight_Direct_Point(kFragment); 
	
	// Compute reflection
	float3 vViewOut = reflect(kFragment.View, kFragment.Normal);
	float3 vReflection = tEnvironment.Sample(sLinearSampler, vViewOut).xyz; 
	
	// Compute final color
	float ao = 0.0f;
    // float3 vAmbient = vTest * kMaterial.Albedo;//((kMaterial.Metallic + (1.0f - kMaterial.Roughness)) * 0.5f);
	//float3 vAmbient = kMaterial.Albedo * ((kMaterial.Metallic + (1.0f - kMaterial.Roughness)) * 0.5f);
	output.DirectLighting = vReflectance;

	// Add noise only on non black color
	if(length(output.DirectLighting) > 0.0f)
	{
		//output.DirectLighting += ComputeDithering(_input.Texcoord);
	}
	//output.DirectLighting = kFragment.Position;
	
	// Compute Ambient Occlusion
	// float3 vNormal = normalize(kMaterial.Normal);
	// float3 vTangent = normalize(cross(vNormal, float3(0.99f, 0.0f, 0.0f)));
	// float3 vBitangent = cross(vNormal, vTangent);
	// float fAngle45 = K_PI / 4.0f;
	// float fAperture = tan( K_PI / 4.0f);  
	
	// // Ambient Occlusion
	// float fAmbientOcclusion = TraceCone(kFragment.Position, vNormal, fAperture);
	// fAmbientOcclusion += fAngle45 * TraceCone(kFragment.Position, normalize(vNormal + vTangent), fAperture);
	// fAmbientOcclusion += fAngle45 * TraceCone(kFragment.Position, normalize(vNormal - vTangent), fAperture);
	// fAmbientOcclusion += fAngle45 * TraceCone(kFragment.Position, normalize(vNormal + vBitangent), fAperture);
	// fAmbientOcclusion += fAngle45 * TraceCone(kFragment.Position, normalize(vNormal - vBitangent), fAperture);
	// fAmbientOcclusion = 1.0f - fAmbientOcclusion;
	// output.AmbientOcclusion = float4(fAmbientOcclusion.xxx, 1.0f);
	// //float4 vAmbientOcclusion = float4(1.0f, 0.0f, 0.0f, 1.0f);
	
	// // Compute Indirect Light
	// float fWeight = (K_PI / 20.0f);
	// float4 vIndirect = float4(TraceCone2(kFragment.Position, vNormal), 1.0f);
	// /*vIndirect.xyz += fWeight * TraceCone2(kFragment.Position, vNormal + vTangent);
	// vIndirect.xyz += fWeight * TraceCone2(kFragment.Position, vNormal - vTangent);
	// vIndirect.xyz += fWeight * TraceCone2(kFragment.Position, vNormal + vBitangent);
	// vIndirect.xyz += fWeight * TraceCone2(kFragment.Position, vNormal - vBitangent);*/
	// output.IndirectLighting = vIndirect;
	
	return output;
}